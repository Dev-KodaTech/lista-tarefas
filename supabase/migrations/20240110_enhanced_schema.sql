-- Add priority and labels to todos
ALTER TABLE public.todos
ADD COLUMN priority text CHECK (priority in ('high', 'medium', 'low')),
ADD COLUMN labels text[] DEFAULT '{}',
ADD COLUMN description text,
ADD COLUMN due_time time without time zone,
ADD COLUMN reminder_time timestamp with time zone,
ADD COLUMN parent_id bigint REFERENCES public.todos(id) ON DELETE CASCADE,
ADD COLUMN position integer DEFAULT 0,
ADD COLUMN is_recurring boolean DEFAULT false,
ADD COLUMN recurrence_pattern jsonb;

-- Add full text search
ALTER TABLE public.todos
ADD COLUMN search_vector tsvector
GENERATED ALWAYS AS (
  setweight(to_tsvector('english', coalesce(text, '')), 'A') ||
  setweight(to_tsvector('english', coalesce(description, '')), 'B') ||
  setweight(to_tsvector('english', coalesce(note, '')), 'C')
) STORED;

CREATE INDEX todos_search_idx ON public.todos USING gin(search_vector);
CREATE INDEX todos_parent_id_idx ON public.todos(parent_id);
CREATE INDEX todos_labels_idx ON public.todos USING gin(labels);
CREATE INDEX todos_position_idx ON public.todos(position);
CREATE INDEX todos_reminder_time_idx ON public.todos(reminder_time);

-- Create notifications table
CREATE TABLE public.notifications (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    user_id uuid references auth.users(id) on delete cascade not null,
    todo_id bigint references public.todos(id) on delete cascade,
    type text not null CHECK (type in ('due_soon', 'overdue', 'completed', 'reminder', 'daily_digest', 'weekly_report')),
    title text not null,
    message text not null,
    read boolean default false,
    metadata jsonb default '{}'::jsonb
);

CREATE INDEX notifications_user_id_idx ON public.notifications(user_id);
CREATE INDEX notifications_todo_id_idx ON public.notifications(todo_id);
CREATE INDEX notifications_read_idx ON public.notifications(read);
CREATE INDEX notifications_type_idx ON public.notifications(type);

-- Create user preferences table
CREATE TABLE public.user_preferences (
    user_id uuid references auth.users(id) on delete cascade primary key,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
    email_notifications boolean default true,
    push_notifications boolean default true,
    reminder_time integer default 30, -- minutes before due date
    overdue_notifications boolean default true,
    daily_digest boolean default false,
    weekly_report boolean default false,
    theme text default 'light',
    time_zone text default 'UTC',
    date_format text default 'YYYY-MM-DD',
    time_format text default '24h',
    start_of_week integer default 0, -- 0 = Sunday
    default_view text default 'list',
    settings jsonb default '{}'::jsonb
);

-- Create function to update user preferences updated_at
CREATE OR REPLACE FUNCTION public.handle_user_preferences_updated_at()
RETURNS trigger AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for user_preferences updated_at
CREATE TRIGGER handle_user_preferences_updated_at
    BEFORE UPDATE ON public.user_preferences
    FOR EACH ROW
    EXECUTE PROCEDURE public.handle_user_preferences_updated_at();

-- Enable RLS on new tables
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_preferences ENABLE ROW LEVEL SECURITY;

-- Create policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON public.notifications FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own notifications"
    ON public.notifications FOR UPDATE
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Create policies for user preferences
CREATE POLICY "Users can view their own preferences"
    ON public.user_preferences FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own preferences"
    ON public.user_preferences FOR UPDATE
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can insert their own preferences"
    ON public.user_preferences FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Function to clean up old notifications
CREATE OR REPLACE FUNCTION public.cleanup_old_notifications()
RETURNS void AS $$
BEGIN
    DELETE FROM public.notifications
    WHERE created_at < (now() - interval '30 days')
    AND type NOT IN ('daily_digest', 'weekly_report');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to generate daily digest
CREATE OR REPLACE FUNCTION public.generate_daily_digest()
RETURNS void AS $$
DECLARE
    user_record RECORD;
BEGIN
    FOR user_record IN
        SELECT user_id
        FROM public.user_preferences
        WHERE daily_digest = true
    LOOP
        INSERT INTO public.notifications (user_id, type, title, message, metadata)
        SELECT
            user_record.user_id,
            'daily_digest',
            'Your Daily Todo Summary',
            'Here is your todo summary for today',
            jsonb_build_object(
                'total_todos', COUNT(*),
                'completed_todos', COUNT(*) FILTER (WHERE completed = true),
                'overdue_todos', COUNT(*) FILTER (WHERE completed = false AND date < CURRENT_DATE),
                'today_todos', COUNT(*) FILTER (WHERE date = CURRENT_DATE)
            )
        FROM public.todos
        WHERE user_id = user_record.user_id
        AND (date = CURRENT_DATE OR (completed = false AND date < CURRENT_DATE));
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to generate weekly report
CREATE OR REPLACE FUNCTION public.generate_weekly_report()
RETURNS void AS $$
DECLARE
    user_record RECORD;
BEGIN
    FOR user_record IN
        SELECT user_id
        FROM public.user_preferences
        WHERE weekly_report = true
    LOOP
        INSERT INTO public.notifications (user_id, type, title, message, metadata)
        SELECT
            user_record.user_id,
            'weekly_report',
            'Your Weekly Todo Report',
            'Here is your todo report for the past week',
            jsonb_build_object(
                'total_todos', COUNT(*),
                'completed_todos', COUNT(*) FILTER (WHERE completed = true),
                'completion_rate', (COUNT(*) FILTER (WHERE completed = true)::float / NULLIF(COUNT(*), 0)::float * 100),
                'overdue_todos', COUNT(*) FILTER (WHERE completed = false AND date < CURRENT_DATE),
                'categories', (
                    SELECT jsonb_object_agg(category, total)
                    FROM (
                        SELECT category, COUNT(*) as total
                        FROM public.todos
                        WHERE user_id = user_record.user_id
                        AND created_at >= (CURRENT_DATE - interval '7 days')
                        GROUP BY category
                    ) categories
                )
            )
        FROM public.todos
        WHERE user_id = user_record.user_id
        AND created_at >= (CURRENT_DATE - interval '7 days');
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER; 